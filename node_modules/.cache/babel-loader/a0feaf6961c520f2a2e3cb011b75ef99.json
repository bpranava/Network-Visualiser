{"ast":null,"code":"import React, { useState, useEffect } from 'react';\n\nvar PathMarker = function PathMarker(props) {\n  var _useState = useState(3),\n      radius = _useState[0],\n      setRadius = _useState[1];\n\n  var _useState2 = useState(props[\"color\"] || \"#ADD8E6\"),\n      color = _useState2[0];\n\n  var _useState3 = useState(props[\"borderColor\"] || \"#EEEEEE\"),\n      borderColor = _useState3[0];\n\n  var optionalNoRef = React.createRef();\n\n  var _useState4 = useState(props[\"markerRef\"] || optionalNoRef),\n      markerRef = _useState4[0];\n\n  var pathRef = props.pathRef;\n  var svgRef = props.svgRef;\n\n  var _useState5 = useState({\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  }),\n      markerRect = _useState5[0],\n      setMarkerRect = _useState5[1];\n\n  useEffect(function () {\n    var updateMarker = function updateMarker() {\n      if (svgRef && pathRef && svgRef.current && pathRef.current && markerRef && markerRef.current) {\n        var svgRect = svgRef.current.getBoundingClientRect();\n        var pathRect = pathRef.current.getBoundingClientRect();\n\n        var _markerRect = markerRef.current.getBoundingClientRect();\n\n        var w = _markerRect.width;\n        var h = _markerRect.height;\n        var x = pathRect.x + 0.5 * pathRect.width - svgRect.x;\n        var y = pathRect.y + 0.5 * pathRect.height - svgRect.y;\n        setMarkerRect({\n          x: x,\n          y: y,\n          w: w,\n          h: h\n        });\n      }\n    };\n\n    if (pathRef && pathRef.current) {\n      window.addEventListener('resize', function () {\n        updateMarker();\n      });\n      window.addEventListener(\"load\", function () {\n        updateMarker();\n      });\n      pathRef.current.addEventListener(\"mouseover\", function () {\n        if (markerRef && markerRef.current) {\n          markerRef.current.style.strokeWidth = \"2\";\n          markerRef.current.style.strokeOpacity = \"0.5\";\n          setRadius(5);\n        }\n      });\n      pathRef.current.addEventListener(\"mouseout\", function () {\n        if (markerRef && markerRef.current) {\n          markerRef.current.style.strokeWidth = \"1\";\n          markerRef.current.style.strokeOpacity = \"0.2\";\n          setRadius(3);\n        }\n      });\n    }\n  }, [pathRef, svgRef, markerRef, markerRect]);\n  return React.createElement(\"g\", {\n    pointerEvents: \"none\"\n  }, React.createElement(\"circle\", {\n    r: radius,\n    fill: color,\n    stroke: borderColor,\n    cx: markerRect.x,\n    cy: markerRect.y,\n    onMouseOver: function onMouseOver(event) {\n      event.currentTarget.style.strokeWidth = \"2\";\n      event.currentTarget.style.strokeOpacity = \"0.5\";\n      setRadius(5);\n    },\n    onMouseOut: function onMouseOut(event) {\n      event.currentTarget.style.strokeWidth = \"1\";\n      event.currentTarget.style.strokeOpacity = \"0.2\";\n      setRadius(3);\n    },\n    ref: markerRef\n  }));\n};\n\nexport { PathMarker };","map":{"version":3,"sources":["../src/ReactPathMarker.tsx"],"names":["PathMarker","radius","setRadius","useState","color","props","borderColor","optionalNoRef","React","markerRef","pathRef","svgRef","markerRect","setMarkerRect","x","y","w","h","useEffect","updateMarker","svgRect","pathRect","window","pointerEvents","r","fill","stroke","cx","cy","onMouseOver","event","onMouseOut","ref"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react'\n\ninterface IProps {\n  pathRef: React.RefObject<SVGElement>,\n  svgRef: React.RefObject<SVGSVGElement>,\n  markerRef?: React.RefObject<SVGCircleElement>;\n  color?: string,\n  borderColor?: string\n}\n\nexport const PathMarker: React.FC<IProps> = (props) => {\n    const [radius, setRadius] = useState(3)\n    const [color, ] = useState (props[\"color\"] || \"#ADD8E6\")\n    const [borderColor, ] = useState (props[\"borderColor\"] || \"#EEEEEE\")\n    const optionalNoRef = React.createRef<SVGCircleElement>()\n    const [markerRef, ] = useState (props[\"markerRef\"] || optionalNoRef)\n    const pathRef = props.pathRef\n    const svgRef = props.svgRef\n    const [markerRect, setMarkerRect] = useState({ x: 0, y: 0, w: 0, h: 0})\n    \n    useEffect(() => {\n        const updateMarker = () => {\n            if(svgRef && pathRef && svgRef.current && pathRef.current && markerRef && markerRef.current) {\n                const svgRect = svgRef.current.getBoundingClientRect()\n                const pathRect = pathRef.current.getBoundingClientRect()\n                const markerRect = markerRef.current.getBoundingClientRect()\n\n                const w = markerRect.width\n                const h = markerRect.height\n                const x = (pathRect.x + 0.5 * pathRect.width - svgRect.x)\n                const y = (pathRect.y + 0.5 * pathRect.height - svgRect.y)\n\n                setMarkerRect({ x: x, y: y, w: w, h: h})\n            }\n        }\n\n        if (pathRef && pathRef.current) {\n           window.addEventListener('resize', () => { updateMarker() })\n           window.addEventListener(\"load\", () => { updateMarker() })\n           pathRef.current.addEventListener(\"mouseover\", () => {if (markerRef && markerRef.current) { markerRef.current.style.strokeWidth = \"2\"; markerRef.current.style.strokeOpacity = \"0.5\"; setRadius(5); }})\n           pathRef.current.addEventListener(\"mouseout\", () => {if (markerRef && markerRef.current) { markerRef.current.style.strokeWidth = \"1\"; markerRef.current.style.strokeOpacity = \"0.2\"; setRadius(3); }})\n        }\n    }, [pathRef, svgRef, markerRef, markerRect])\n\n    return (\n        <g pointerEvents={\"none\"}>\n           <circle \n            r={radius}\n            fill={color}\n            stroke={borderColor}\n            cx={markerRect.x}\n            cy={markerRect.y} \n            onMouseOver={(event) => { event.currentTarget.style.strokeWidth = \"2\"; event.currentTarget.style.strokeOpacity = \"0.5\"; setRadius(5)}}\n            onMouseOut={(event) => { event.currentTarget.style.strokeWidth = \"1\"; event.currentTarget.style.strokeOpacity = \"0.2\"; setRadius(3)}}\n            ref={markerRef}\n           />\n        </g>\n    )\n}"]},"metadata":{},"sourceType":"module"}